// Copyright 2001-2018 Crytek GmbH / Crytek Group. All rights reserved.


////////////////////////////////////////////////////////////////////////////
// Important Note:
//
// Wave occupancy is essential to get a performance benefit from tiled deferred shading.
// Branch heavy code can increase the number of VGPRs that are required to execute
// the shader which in turn will lower the wave occupancy.
// When modifying the shader code, please check in PIX on Xbox One that the occupancy is
// at least 3 for the tiled deferred shading pass.
//
////////////////////////////////////////////////////////////////////////////


// The following constants and structs have to match the engine code!!

#define TILED_SHADING_MAX_NUM_LIGHTS  255
#define TILED_SHADING_TILE_SIZE_X       8
#define TILED_SHADING_TILE_SIZE_Y       8

#define TILED_THREAD_GROUP_SIZE		TILED_SHADING_TILE_SIZE_X * TILED_SHADING_TILE_SIZE_Y

struct STiledLightCullInfo
{
	uint      volumeType;
	uint      PADDING0;
	float2    depthBounds;
	float4    posRad;
	float4    volumeParams0;
	float4    volumeParams1;
	float4    volumeParams2;
};

struct STiledLightVolumeVertex
{
	float3 position;
};

struct STiledLightVolumeInfo
{
	float4x4  worldMat;
	float4    volumeTypeInfo;
	float4    volumeParams0;
	float4    volumeParams1;
	float4    volumeParams2;
	float4    volumeParams3;
};

struct STiledClipVolumeInfo
{
	uint		data; // bits 0-15 reserved for flags, 16-23 blendID1, 24-31 blendID0
};

#define TILEDLIGHT_VOLUME_SPHERE   1
#define TILEDLIGHT_VOLUME_CONE     2
#define TILEDLIGHT_VOLUME_OBB      3
#define TILEDLIGHT_VOLUME_SUN      4

////////////////////////////////////////////////////////////////////////////

Buffer<uint>                           Fwd_TileLightMask : register(t17);
StructuredBuffer<STiledLightShadeInfo> Fwd_TiledLightsShadeInfo : register(t18);
StructuredBuffer<STiledClipVolumeInfo> Fwd_TiledClipVolumeInfo : register(t19);
TextureCubeArray<float4>               Fwd_SpecCubeArray : register(t20);
TextureCubeArray<float4>               Fwd_DiffuseCubeArray : register(t21);
Texture2DArray<float4>                 Fwd_SpotTexArray : register(t22);
Texture2D<float4>                      Fwd_ShadowPool : register(t23);
Texture2D<float4>                      Fwd_RandomRotations : register(t24);
Texture2D<float4>                      Fwd_EnvironmentBRDF : register(t40);

#if FEATURE_SVO_GI
Texture2D<float4>                      Fwd_GiDiffuseRT : register(t46);
Texture2D<float4>                      Fwd_GiSpecularRT : register(t47);
#endif

SamplerComparisonState SampStateComp : register(s14);
SamplerState SampStateTrilinearClamp : register(s15);

#define SHADOW_SAMPLE_COUNT 16
float4 irreg_kernel_2d[SHADOW_SAMPLE_COUNT/2] : PB_IrregKernel;

#ifndef AFFECTS_EVERYTHING_STENCILREF 
#define AFFECTS_EVERYTHING_STENCILREF	0xFF
#endif

uint4 GetResourceIndexAndMipClamps(uint resIndex)
{
	const uint resIndexID   = (resIndex & 0xFFFF);
	const uint resMipClamp0 = (resIndex >> 16) & 0xFF;
	const uint resMipClamp1 = (resIndex >> 24) & 0xFF;
	
	return uint4(resIndexID, resMipClamp0, resMipClamp1, 0.0f);
}

float GetClipVolumeWeightBinary(uint nClipVolumeID, uint nLightStencilID)
{
	const uint nLightStencilID0 = nLightStencilID & 0xFF;
	const uint nLightStencilID1 = nLightStencilID >> 16;
	
	return (nLightStencilID0 == AFFECTS_EVERYTHING_STENCILREF || nClipVolumeID == nLightStencilID0 || nClipVolumeID == nLightStencilID1) ? 1.0f : 0.0f;
}

#if FEATURE_SVO_GI
void ApplyGI(inout float3 specularAcc, inout float3 diffuseAcc, float3 diffuseForwAcc, float2 pixelUV, float3 surfGloss, float3 surfSpecCol,
             Texture2D<float4> TexGiDiffuse, Texture2D<float4> TexGiSpecular, SamplerState samplerTrilinearClamp, const int nIntegrMode, float4 fParms)
{
	if(nIntegrMode == 0) // AO only mode
	{
		float4 vSkyLightIrradiance = TexGiDiffuse.SampleLevel( samplerTrilinearClamp, pixelUV, 0 );
		specularAcc *= lerp(vSkyLightIrradiance.xyz, 1.f, surfGloss * GetLuminance(surfSpecCol));
		diffuseAcc *= vSkyLightIrradiance.xyz; // AO + sun bounces
	}
	else if(nIntegrMode == 1) // GI replaces diffuse of env probes and adjusts specular
	{
		float3 diffuseIrradiance = TexGiDiffuse.SampleLevel( samplerTrilinearClamp, pixelUV, 0 );
		specularAcc *= lerp(min( 2.f, GetLuminance(diffuseIrradiance) / (GetLuminance(diffuseAcc + diffuseForwAcc) + 0.001)), 1.f, saturate(surfGloss * GetLuminance(surfSpecCol) * fParms.x)) * fParms.z;
		diffuseAcc = diffuseIrradiance;
	}
	else if(nIntegrMode == 2) // Full GI mode
	{
		diffuseAcc = TexGiDiffuse.SampleLevel( samplerTrilinearClamp, pixelUV, 0 );
		specularAcc = TexGiSpecular.SampleLevel( samplerTrilinearClamp, pixelUV, 0 );
	}
}
#endif

int GetNextTileLightIndex(uint lightMask, int startIndex)
{
	uint mask = startIndex < 31 ? ~((1 << (startIndex + 1)) - 1) : 0;
	return firstbitlow(lightMask & mask);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
#if !TILED_DEFERRED_SHADING_TECHNIQUE
////////////////////////////////////////////////////////////////////////////////////////////////////

void TiledForwardShading(in ForwardShadingAttribs attribs, inout float3 diffuseAcc, inout float3 specularAcc, SamplerState ssTrilinearClamp, SamplerComparisonState ssComparison,
                         const bool shadowHighQualityFiltering, const bool applyProbes, const bool applyNonProbes, const bool bSkipSpecularProbes = false, const bool bOpaque = false)
{
	uint2 numTiles = ceil( CV_ScreenSize.xy / float2(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y) );
	
	float2 tcProj = attribs.screenUV;
	uint2 tileIdx = uint2( tcProj.x * numTiles.x, tcProj.y * numTiles.y );
	uint bufferIdx = (tileIdx.y * numTiles.x + tileIdx.x) * 8;
	
	float probeWeightSum = 0;
	float3 viewVec = -normalize(attribs.worldPos);
	float specCubeLod = TILED_SHADING_SPECPROBE_MAXMIP - attribs.smoothness * TILED_SHADING_SPECPROBE_MAXMIP;
	float NdotV = saturate(dot(viewVec, attribs.normalSpecProbe));
	float3 envFresnel = GetEnvmapFresnel(attribs.reflectance, attribs.smoothness, NdotV);
	float2 envBRDF = Fwd_EnvironmentBRDF.SampleLevel(ssTrilinearClamp, float2(NdotV, attribs.smoothness), 0).xy;
	envFresnel = lerp(envBRDF.xxx, envBRDF.yyy, attribs.reflectance);

	float2 occlusion = float2(1, 1);
    float occlSpec = 1;
	if (bOpaque)
	{
		float aoAmount = Fwd_RandomRotations[attribs.screenUV * CV_ScreenSize.xy].w;
		float occlDiff = saturate(1 - aoAmount * 1.0);
		occlSpec = saturate(1 - aoAmount * 1.5);
		occlusion.x = occlDiff * occlDiff;
		occlusion.y = DeriveSpecularOcclusion(NdotV, max(occlSpec * occlSpec, 0.3), attribs.smoothness);
	}
	
	int lightIndex = -1;
	uint maskIndex = 0;
	uint curMask = Fwd_TileLightMask[bufferIdx];
	
	[loop]
	for (;;)
	{
		while (maskIndex < 8)
		{
			lightIndex = GetNextTileLightIndex(curMask, lightIndex);
			if (lightIndex >= 0) break;
			else curMask = Fwd_TileLightMask[++maskIndex + bufferIdx];
		}

		uint lightShadeInfoIdx = lightIndex + maskIndex * 32;
		int lightType = Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].lightType;
		
		[branch]
		if (lightIndex < 0 || lightType > LIGHT_TYPE_AMBIENT_AREA)
			break;
			
		if (applyProbes)
		{
			const float clipVolumeWeight = 1;  // TODO
			if (lightType == LIGHT_TYPE_PROBE && probeWeightSum < 1 && clipVolumeWeight > 0)
			{
				float3 lightVec = Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].posRad.xyz - (attribs.worldPos + GetWorldViewPos());
				
				// Compute attenuation for box
				float3 tmpLightVec;
				tmpLightVec.x = dot( Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix[0].xyz, lightVec );
				tmpLightVec.y = dot( Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix[1].xyz, lightVec );
				tmpLightVec.z = dot( Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix[2].xyz, lightVec );
				
				[branch] if (abs(tmpLightVec.x) < 1 && abs(tmpLightVec.y) < 1 && abs(tmpLightVec.z) < 1)  // Required for correctness and performance
				{
					tmpLightVec = MapCubeToSphere( tmpLightVec );
					float4 lightColor = Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].color;

					float attenuation = GetAttenuation( tmpLightVec, 1, true, Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].attenuationParams.y ) * Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].attenuationParams.x;
                    uint4 resIndexClamps = GetResourceIndexAndMipClamps(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].resIndex);
                    float probeWeight = (1 - probeWeightSum) * attenuation;
				
#ifndef TILED_SHADING_USER_DEFINED_PROBE_CALLBACK
					// Diffuse
					float4 diffuseProbe = Fwd_DiffuseCubeArray.SampleLevel( ssTrilinearClamp, float4( attribs.normal, resIndexClamps.x ), resIndexClamps.y );
					diffuseProbe.rgb = DecodeHDRCubemap( diffuseProbe );
					diffuseAcc += diffuseProbe.rgb * (lightColor.rgb * probeWeight) * occlusion.x;
			
					if (!bSkipSpecularProbes)
					{
						// Specular
						float tmpGloss = 0;
						float3 tmpReflVec = reflect(-viewVec, attribs.normalSpecProbe);
						CubemapBoxParallaxCorrection( tmpReflVec, lightVec, Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowMatrix[0].xyz, Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowMatrix[1].xyz, tmpGloss );
						float4 specularProbe = Fwd_SpecCubeArray.SampleLevel( ssTrilinearClamp, float4( tmpReflVec, resIndexClamps.x ), max(resIndexClamps.z, specCubeLod) );
						specularProbe.rgb = DecodeHDRCubemap( specularProbe ) * envFresnel;
						specularAcc += specularProbe.rgb * (lightColor.rgb * probeWeight) * occlusion.y * lightColor.a;
					}	
#else
                    Callback_ShadingProbe(attribs, Fwd_TiledLightsShadeInfo[lightShadeInfoIdx], lightVec,
                           probeWeight, NdotV, occlusion, occlSpec, resIndexClamps, ssTrilinearClamp,
                           diffuseAcc, specularAcc);
#endif
					
					probeWeightSum += probeWeight;
				}
			}
		}
	}
		
#if FEATURE_SVO_GI
	if (bOpaque)
	{
		ApplyGI(specularAcc, diffuseAcc, diffuseAcc, attribs.screenUV + .5f / CV_ScreenSize.xy, attribs.smoothness, attribs.reflectance, 
			Fwd_GiDiffuseRT, Fwd_GiSpecularRT, ssTrilinearClamp, (int)(cbSVOGI.IntegrationMode.y), cbSVOGI.IntegrationMode);
	}
#endif
	
	[loop]
	for (;;)
	{
		[branch]
		if (lightIndex < 0)
			break;

		uint lightShadeInfoIdx = lightIndex + maskIndex * 32;
		int lightType = Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].lightType;

		const float3 position = attribs.worldPos;
		const float4 posRad = Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].posRad;
		const float3 lightVec = posRad.xyz - (position + GetWorldViewPos());
		
		if (applyNonProbes && lightType > LIGHT_TYPE_AMBIENT_AREA && length( lightVec ) < posRad.w)
		{
			bool skipShading = false;
			bool shadowMap = false;
			
			ForwardLightParams lightParams;
            lightParams.type = lightType;
			lightParams.lightVec = normalize(lightVec);
			lightParams.illuminance = Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].color.rgb;
			
			float attenuation = GetPhysicalLightAttenuation( length( lightVec ), rcp(posRad.w), Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].attenuationParams.x );
			lightParams.illuminance *= attenuation;
			
			const float clipVolumeWeight = 1;

			if (lightType == LIGHT_TYPE_REGULAR_PROJECTOR)
			{
				if (attenuation > 0)
				{
					float4 projTC = mul( Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix, float4( position + GetWorldViewPos(), 1.0f ) );  
					projTC.xy /= projTC.w;		
						
					if (projTC.w < 0 || min( projTC.x, projTC.y ) < 0 || max( projTC.x, projTC.y ) > 1)  // Avoid back-projection
						skipShading = true;
					else
					{
						uint4 resIndexClamps = GetResourceIndexAndMipClamps(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].resIndex);
						lightParams.illuminance *= Fwd_SpotTexArray.SampleLevel( ssTrilinearClamp, float3(projTC.xy, resIndexClamps.x), resIndexClamps.y ).xxx;
					}
						
					if (Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowParams.x > 0)
						shadowMap = true;
				}
			}
			else if (lightType == LIGHT_TYPE_REGULAR_POINTFACE)
			{
				uint cubeFace = selectCubeFace(lightVec);
				
				skipShading = (Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].resIndex != cubeFace);
				shadowMap   = true;
			}
				
			if (!skipShading)
			{
				float shadowOccl = 1;
				
				if (shadowMap)
				{
					float4 P0 = mul( Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowMatrix, float4( position + GetWorldViewPos(), 1 ) );
					P0.xy /= P0.w;
					P0.z -= Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowParams.y;
					
					bool bAllowHighQualityShadows = false;
					
					if (bOpaque)
					{
						int3 sampleCoords = int3(attribs.screenUV * CV_ScreenSize.xy, Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowMaskIndex);
						shadowOccl = 1 - Fwd_SunShadowMask[sampleCoords];
					}
					else if (shadowHighQualityFiltering && bAllowHighQualityShadows)
					{
						float2 kernelRadius = Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].shadowParams.x;
						float2 rotScale = kernelRadius.y * 1000.0f;

						const int nRotationTextureSize = 64;
						int2 sampleCoords = int2(P0.xy * rotScale.xy * nRotationTextureSize) % nRotationTextureSize;
						
						half2 rotSample = Fwd_RandomRotations.Load(int3(sampleCoords, 0)).xy;
						rotSample.xy *= kernelRadius.xy * 1/512.0f;
						float4 rot = float4(rotSample.x, -rotSample.y, rotSample.y, rotSample.x);
						
						shadowOccl = 0;
						for(int s = 0; s < SHADOW_SAMPLE_COUNT / 2; s += 2) // Loop over taps
						{
							half4 sampleDepth;
							{
								// Rotate tap for this pixel location
								float4 rotatedOff0 = rot.xyzw * irreg_kernel_2d[s+0].xxww +	rot.zwxy * irreg_kernel_2d[s+0].yyzz;
								float4 rotatedOff1 = rot.xyzw * irreg_kernel_2d[s+1].xxww +	rot.zwxy * irreg_kernel_2d[s+1].yyzz;

								sampleDepth.x = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy + rotatedOff0.xy, P0.z);
								sampleDepth.y = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy + rotatedOff0.zw, P0.z);
								sampleDepth.z = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy + rotatedOff1.xy, P0.z);
								sampleDepth.w = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy + rotatedOff1.zw, P0.z);
							}

							shadowOccl += dot(sampleDepth, 1.0 / SHADOW_SAMPLE_COUNT);
						}
					}
					else
					{
						shadowOccl = Fwd_ShadowPool.SampleCmpLevelZero( ssComparison, P0.xy, P0.z );
					}
				}

				lightParams.illuminance *= shadowOccl;

                float3 diffuseTerm = 0;
                float3 specularTerm = 0;

                attribs.areaAttribs.transform = Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].projectorMatrix;
                attribs.areaAttribs.lightPos = Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].posRad.xyz - GetWorldViewPos();
                attribs.areaAttribs.position = position;
                attribs.areaAttribs.lightArrayIdx = GetResourceIndexAndMipClamps(Fwd_TiledLightsShadeInfo[lightShadeInfoIdx].resIndex).x;

                Callback_ShadingDirect(attribs, lightParams, diffuseAcc, specularTerm);

				diffuseAcc += diffuseTerm;
                specularAcc += specularTerm;
            }
		}
		
		while (maskIndex < 8)
		{
			lightIndex = GetNextTileLightIndex(curMask, lightIndex);
			if (lightIndex >= 0) break;
			else curMask = Fwd_TileLightMask[++maskIndex + bufferIdx];
		}
	}
}

#endif


////////////////////////////////////////////////////////////////////////////////////////////////////
#if TILED_DEFERRED_SHADING_TECHNIQUE
////////////////////////////////////////////////////////////////////////////////////////////////////

// The benefit of using the depth mask is currently not enough to cover the cost of generating it
//#define USE_DEPTH_MASK

float4 ProjParams;
float4 ScreenSize;
float4 SunDir;
float4 SunColor;
float4 SSDOParams;
#if FEATURE_SVO_GI
float4 ForwGiIntegrationMode : PB_SvoParams4;
#endif

RWBuffer<uint> TileTranspLightMaskUAV : register(u0);
RWTexture2D<float3> HDRSceneTargetUAV : register(u1);
RWTexture2D<float3> DiffuseAccUAV : register(u2);

Texture2D<float>  DepthRT: register(t0);
Texture2D<float4> NormalRT : register(t1);
Texture2D<float4> SpecularRT : register(t2);
Texture2D<float4> DiffuseRT : register(t3);
Texture2DArray<float4> ShadowMaskRT : register(t4);
Texture2D<float4> DirectionalOccRT : register(t5);
Texture2D<float4> SSReflectionRT : register(t6);
Texture2D<float4> EnvBRDF : register(t7);
Texture2D<float2> ClipVolumeIndexRT : register(t8);
Texture2D<float4> AOColorBleedRT : register(t9);
Texture2D<float4> GiDiffuseRT : register(t10);
Texture2D<float4> GiSpecularRT : register(t11);
Texture2D<float3> CausticsRT : register(t12);

Buffer<uint>                           TileLightMask : register(t16);
StructuredBuffer<STiledLightCullInfo>  TiledLightsCullInfo : register(t16);
StructuredBuffer<STiledLightShadeInfo> TiledLightsShadeInfo : register(t17);
StructuredBuffer<STiledClipVolumeInfo> TiledClipVolumeInfo : register(t18);
TextureCubeArray<float4>               SpecCubeArray : register(t19);
TextureCubeArray<float4>               DiffuseCubeArray : register(t20);
Texture2DArray<float4>                 SpotTexArray : register(t21);


groupshared uint sTileLightCount;
groupshared uint sTileLightIndices[TILED_SHADING_MAX_NUM_LIGHTS];
groupshared uint sTileMinZ;
groupshared uint sTileMaxZ;
groupshared uint sTileDepthMask;
groupshared uint sTileWithinProjection;
groupshared uint sTileLightMask[8];
groupshared uint sTileLightMaskCounts[8];

////////////////////////////////////////////////////////////////////////////////////////////////////

[numthreads(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y, 1)]
void TiledDeferredShadingCS( uint3 GroupID : SV_GroupID,
                             uint3 GroupThreadID : SV_GroupThreadID )
{
	const uint groupThreadIdx = GroupThreadID.y * TILED_SHADING_TILE_SIZE_X + GroupThreadID.x;
	const uint2 pixelCoord = GroupID.xy * uint2(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y) + GroupThreadID.xy;
	
	// Barycentric interpolation for reconstructing position
	float2 pixelUV = float2( (pixelCoord.x + 0.5) * ScreenSize.z, (pixelCoord.y + 0.5) * ScreenSize.w );
	float2 linearUV = MapRasterToViewport(pixelUV);
	
	// Initialize shared memory
	if (groupThreadIdx == 0)
	{
		sTileLightCount = 0;
		sTileWithinProjection = 0;
	}

	GroupMemoryBarrierWithGroupSync();
	
	// Find out if any threads in the tile are within the projection
	{
		uint bWithinProjection = all(linearUV.xy > 0) && all(linearUV.xy < 1);
		
		InterlockedMax( sTileWithinProjection, bWithinProjection );
		
		GroupMemoryBarrierWithGroupSync();
	
		if (sTileWithinProjection == 0)
			return;
	}
	
#if !%_RT_SAMPLE1	
	// Initialize shared memory
	if (groupThreadIdx == 0)
	{
		sTileMinZ = 0x7F7FFFFF;  // Max float
		sTileMaxZ = 0;
		sTileDepthMask = 0;
	}
	
	sTileLightIndices[groupThreadIdx] = TILED_SHADING_MAX_NUM_LIGHTS;
	
	// Fudge maxZ to prevent division by 0 when minZ is equal maxZ
	// it also assures the depth-mask bins of [0,32) instead of [0,32]
	float linearZ = DepthRT[pixelCoord];
	float minZSample = linearZ;
	float maxZSample = linearZ + 0.0001;

	// Find tile z bounds
	GroupMemoryBarrierWithGroupSync();
	
	InterlockedMin( sTileMinZ, asuint( minZSample ) );
	InterlockedMax( sTileMaxZ, asuint( maxZSample ) );
	
	GroupMemoryBarrierWithGroupSync();
	
	float tileMinZ = asfloat( sTileMinZ );
	float tileMaxZ = asfloat( sTileMaxZ );
	bool emptyTile = (tileMinZ == 1.0);
	bool isSkyPixel = (linearZ == 1.0);
	
	// Scale and bias for frustum to fit grid cells
	float2 numTiles = ceil( ScreenSize.xy / float2(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y) );
	float2 tileScale = numTiles / 2.0;
	float2 tileBias = tileScale - float2( GroupID.xy );
	
	// Extract projection matrix columns (including PostAA bias)
	float4 col1 = float4( ProjParams.x * tileScale.x, 0.0f, ProjParams.z + tileBias.x, 0.0f );
	float4 col2 = float4( 0.0f, -ProjParams.y * tileScale.y, ProjParams.w + tileBias.y, 0.0f );
	float4 col4 = float4( 0.0f, 0.0f, 1.0f, 0.0f );

	float4 frustumPlanes[4];
	frustumPlanes[0] = normalize( col4 - col1 );
	frustumPlanes[1] = normalize( col4 + col1 );
	frustumPlanes[2] = normalize( col4 - col2 );
	frustumPlanes[3] = normalize( col4 + col2 );
	
#ifdef USE_DEPTH_MASK
	// Create depth coverage mask for tile
	// Fudge guarantees (32  * z) / (z + 0.0001) < 32
	float tileDepthExtent = rcp( tileMaxZ - tileMinZ );
	uint cellIndex = ((linearZ - tileMinZ) * tileDepthExtent) * 32;
	GroupMemoryBarrierWithGroupSync();
	InterlockedOr( sTileDepthMask, 1UL << cellIndex );
	GroupMemoryBarrierWithGroupSync();
#endif
	
	// ==============================================================================================
	// Light culling
	// ==============================================================================================
	
	uint tileIdx = GroupID.y * numTiles.x + GroupID.x;
	
	// Cull against frustum planes
	[unroll]
	for (uint lightIdx = groupThreadIdx; lightIdx < TILED_SHADING_MAX_NUM_LIGHTS; lightIdx += TILED_THREAD_GROUP_SIZE)
	{
		uint volumeType = TiledLightsCullInfo[lightIdx].volumeType;
		
		if (volumeType == 0)
			break;
		
		const float lightMinZ = TiledLightsCullInfo[lightIdx].depthBounds.x;
		const float lightMaxZ = TiledLightsCullInfo[lightIdx].depthBounds.y;

		// Test far plane
		// The tileMaxZ value is a bit larger than the real maximum Z because of the fudge: use < instead of <=
		bool inFrustum = ( lightMinZ < tileMaxZ );
		
		if (inFrustum)
		{
			float4 lightPosRad = TiledLightsCullInfo[lightIdx].posRad;
			float4 lightDists;
			
			[unroll]
			for (uint j = 0; j < 4; ++j)
			{
				lightDists[j] = dot( frustumPlanes[j], float4( lightPosRad.xyz, 1 ) );
			}
			
			if (volumeType == TILEDLIGHT_VOLUME_SPHERE)
			{
				[unroll]
				for (uint j = 0; j < 4; ++j)
				{
					// Simple sphere culling
					inFrustum = inFrustum && (lightDists[j] >= -lightPosRad.w);
				}
			}
			else if (volumeType == TILEDLIGHT_VOLUME_CONE)
			{
				const float4 spotParams = TiledLightsCullInfo[lightIdx].volumeParams0;
				
				[unroll]
				for (uint j = 0; j < 4; ++j)
				{
					// Cone culling
					float3 v = spotParams.xyz;
					float3 Q = lightPosRad.xyz - v * lightPosRad.w;
					Q += spotParams.w * (frustumPlanes[j].xyz - v * dot( v, frustumPlanes[j].xyz ));
					float dBase = dot( frustumPlanes[j], float4( Q, 1.0f ) );
					inFrustum = inFrustum && (((lightDists[j] > 0) || (dBase > 0)) && (lightDists[j] >= -lightPosRad.w));  // Including sphere test for more accurate culling
				}
			}
			else if (volumeType == TILEDLIGHT_VOLUME_OBB)
			{
				float4 u0 = TiledLightsCullInfo[lightIdx].volumeParams0;
				float4 u1 = TiledLightsCullInfo[lightIdx].volumeParams1;
				float4 u2 = TiledLightsCullInfo[lightIdx].volumeParams2;
				
				[unroll]
				for (uint j = 0; j < 4; ++j)
				{
					// OBB culling
					float r = dot( float3( u0.w, u1.w, u2.w ), float3( abs(dot( frustumPlanes[j].xyz, u0.xyz )), abs(dot( frustumPlanes[j].xyz, u1.xyz )), abs(dot( frustumPlanes[j].xyz, u2.xyz )) ) ) ;
					inFrustum = inFrustum && (-lightDists[j] <= r);// detect OBB intersects or is inside the plane.
				}
			}
		
			if (inFrustum)
			{
				// Test near plane
				[branch]
				if ((lightMaxZ >= tileMinZ) && !emptyTile)
				{

				#ifdef USE_DEPTH_MASK
					// saturate() allows [0,1], thus the shift can become 32 if lightMinZ equals exactly lightMaxZ
					// The shift is masked (32 & 0x1F) and does nothing in case 32, except registering the light in all bits (worst case)
					uint lightShiftMin = saturate( (lightMinZ - tileMinZ) * tileDepthExtent ) * 32;
					uint lightShiftMax = saturate( (tileMaxZ - lightMaxZ) * tileDepthExtent ) * 32;
					uint lightMask = (0xFFFFFFFFUL << lightShiftMin) & (0xFFFFFFFFUL >> lightShiftMax);

					if ((lightMask & sTileDepthMask) != 0)
				#endif
					{
						uint listIndex;
						InterlockedAdd( sTileLightCount, 1, listIndex );
						sTileLightIndices[listIndex] = lightIdx;
					}
				}

				[branch]
				if (volumeType != TILEDLIGHT_VOLUME_SUN)
				{
					uint bufferBaseIdx = tileIdx * 8;
					uint maskIndex = lightIdx / 32;
					InterlockedOr(TileTranspLightMaskUAV[bufferBaseIdx + maskIndex], 1 << (lightIdx & 31));
				}
			}
		}
	}
	
	GroupMemoryBarrierWithGroupSync();
	
#if !DURANGO && !ORBIS
	// Apply bitonic sort to the first TILED_THREAD_GROUP_SIZE lights; not required on AMD/Durango when no more than 64 threads are used
	[unroll]
	for (uint k = 2; k <= TILED_THREAD_GROUP_SIZE; k = 2 * k)
	{
		[unroll]
		for (uint j = k / 2; j > 0 ; j /= 2)
		{
				uint i = groupThreadIdx;
				uint result1 = ((sTileLightIndices[i & ~j] <= sTileLightIndices[i | j]) == (bool)(k & i)) ? sTileLightIndices[i ^ j] : sTileLightIndices[i];
				GroupMemoryBarrierWithGroupSync();
				sTileLightIndices[i] = result1;
				GroupMemoryBarrierWithGroupSync();
		}
	}
#endif
	
#else
	float2 numTiles = ceil( ScreenSize.xy / float2(TILED_SHADING_TILE_SIZE_X, TILED_SHADING_TILE_SIZE_Y) );
	uint tileIdx = GroupID.y * numTiles.x + GroupID.x;
	uint bufferBaseIdx = tileIdx * 8;
	
	if (groupThreadIdx < 8)
	{
		uint lightMask = TileLightMask[bufferBaseIdx + groupThreadIdx];
		sTileLightMask[groupThreadIdx] = lightMask;
		sTileLightMaskCounts[groupThreadIdx] = countbits(lightMask);
		InterlockedAdd(sTileLightCount, sTileLightMaskCounts[groupThreadIdx]);
	}

	// Sync for wave(front)s smaller than 8 (e.g. WARP, which is 4 wide with SSE)
	GroupMemoryBarrierWithGroupSync();
	
	if (groupThreadIdx < 8)
	{
		uint offset = 0;
		for (uint i = 0; i < groupThreadIdx; i++)
			offset += sTileLightMaskCounts[i];
		
		uint lightCount = 0;
		int lightIndex = GetNextTileLightIndex(sTileLightMask[groupThreadIdx], -1);
		while (lightIndex >= 0)
		{
			sTileLightIndices[offset + lightCount++] = groupThreadIdx * 32 + lightIndex;
			lightIndex = GetNextTileLightIndex(sTileLightMask[groupThreadIdx], lightIndex);
		}
	}
	
	GroupMemoryBarrierWithGroupSync();

	bool emptyTile = sTileLightCount == 0;
	float linearZ = DepthRT[pixelCoord];
#endif
	
	// ==============================================================================================
	// Overdraw visualization
	// ==============================================================================================
	
#if %_RT_SAMPLE2
	{
		float x = (float)sTileLightCount / 16.0;
		float w0 = x * 2;
		float w1 = x * 2 - 1;
		float3 finalCol = x < 0.5 ? lerp(float3(0, 0, 0.25), float3(1, 0, 0), float3(w0*w0, 0, w0))
		                          : lerp(float3(1, 0, 0.00), float3(1, 1, 0), float3(w1*w1, w1*w1, 0));
		
		if (x == 0) finalCol = float3(0, 0, 0);
		else if (x > 1) finalCol = float3(1, 1, 1);
		
		HDRSceneTargetUAV[pixelCoord] = float4(finalCol, 1);
		return;
	}
#endif
	
	// ==============================================================================================
	// Shading for tiles
	// ==============================================================================================
	
#if %_RT_SAMPLE0
	MaterialAttribsCommon attribs = DecodeGBuffer( NormalRT[pixelCoord], DiffuseRT[pixelCoord], SpecularRT[pixelCoord] );
	float3 surfNormal = attribs.NormalWorld;
	bool surfIsTranslucent = attribs.LightingModel == LIGHTINGMODEL_TRANSMITTANCE;
	float3 surfTransmittanceColor = attribs.Transmittance;
	float3 surfSpecCol = attribs.Reflectance;
	float surfGloss = attribs.Smoothness;

	float3 position = ReconstructWorldPos(pixelCoord, linearZ, true);
	
	float3 diffuseAcc = 0;
	float3 specularAcc = 0;
	
	int curLight = 0;
	int lightIndex = sTileLightCount > 0 ? sTileLightIndices[0] : 0;
	
	const uint 	clipVolumeStencilID = ClipVolumeIndexRT[pixelCoord].x * 255.0f;
	const uint  clipVolumeData = TiledClipVolumeInfo[clipVolumeStencilID & MAX_CLIPVOLUMES].data;
	const float clipVolumeBlendFactor = ClipVolumeIndexRT[pixelCoord].y;
	
	// ==============================================================================================
	// Environment probes
	// ==============================================================================================
	{
		float probeWeightSum = 0;
		float3 reflVec = reflect( normalize( position ), surfNormal );
		float specCubeLod = TILED_SHADING_SPECPROBE_MAXMIP - surfGloss * TILED_SHADING_SPECPROBE_MAXMIP;
		
		while (curLight < sTileLightCount)
		{
			int lightType = TiledLightsShadeInfo[lightIndex].lightType;
			if (lightType != LIGHT_TYPE_PROBE)
				break;

			const float clipVolumeBlendWeight = CalcClipVolumeBlendWeight(clipVolumeStencilID, clipVolumeData, clipVolumeBlendFactor, TiledLightsShadeInfo[lightIndex].stencilID);
			[branch] if (probeWeightSum < 1.0 && clipVolumeBlendWeight > 0)
			{
				float3 lightVec = TiledLightsShadeInfo[lightIndex].posRad.xyz - (position + GetWorldViewPos());
				
				// Compute attenuation for box
				float3 tmpLightVec;
				tmpLightVec.x = dot( TiledLightsShadeInfo[lightIndex].projectorMatrix[0].xyz, lightVec );
				tmpLightVec.y = dot( TiledLightsShadeInfo[lightIndex].projectorMatrix[1].xyz, lightVec );
				tmpLightVec.z = dot( TiledLightsShadeInfo[lightIndex].projectorMatrix[2].xyz, lightVec );
				
				[branch] if (max( max( abs(tmpLightVec.x), abs(tmpLightVec.y) ), abs(tmpLightVec.z) ) < 1)  // Required for correctness and performance
				{
					tmpLightVec = MapCubeToSphere( tmpLightVec );
					float4 lightColor = TiledLightsShadeInfo[lightIndex].color;

					float attenuation = GetAttenuation( tmpLightVec, 1, true, TiledLightsShadeInfo[lightIndex].attenuationParams.y ) * TiledLightsShadeInfo[lightIndex].attenuationParams.x;
					uint4 resIndexClamps = GetResourceIndexAndMipClamps(TiledLightsShadeInfo[lightIndex].resIndex);

					// Diffuse
					float4 diffuseProbe = DiffuseCubeArray.SampleLevel( SampStateTrilinearClamp, float4( surfNormal, resIndexClamps.x ), resIndexClamps.y );
					diffuseProbe.rgb = DecodeHDRCubemap( diffuseProbe );
					[branch] if (surfIsTranslucent)
					{
						float4 diffuseProbe2 = DiffuseCubeArray.SampleLevel( SampStateTrilinearClamp, float4( -surfNormal, resIndexClamps.x ), resIndexClamps.y );
						diffuseProbe.rgb += DecodeHDRCubemap( diffuseProbe2 ) * surfTransmittanceColor;
					}
					float probeWeight = (1 - probeWeightSum) * attenuation * clipVolumeBlendWeight;
					diffuseAcc += diffuseProbe.rgb * (lightColor.rgb * probeWeight);
			
					// Specular
					float tmpGloss = 0;
					float3 tmpReflVec = reflVec;
					CubemapBoxParallaxCorrection( tmpReflVec, lightVec, TiledLightsShadeInfo[lightIndex].shadowMatrix[0].xyz, TiledLightsShadeInfo[lightIndex].shadowMatrix[1].xyz, tmpGloss );
					float4 specularProbe = SpecCubeArray.SampleLevel( SampStateTrilinearClamp, float4( tmpReflVec, resIndexClamps.x ), max(specCubeLod, resIndexClamps.z) );
					specularProbe.rgb = DecodeHDRCubemap( specularProbe );
					specularAcc += specularProbe.rgb * (lightColor.rgb * probeWeight) * lightColor.a;
					
					probeWeightSum += probeWeight;
				}
			}
			
			++curLight;
			lightIndex = sTileLightIndices[min( curLight, TILED_SHADING_MAX_NUM_LIGHTS - 1 )];
		}
	}

#if FEATURE_SVO_GI
	// ==============================================================================================
	// Global Illumination
	// ==============================================================================================
	{
		int nIntegrMode = -1;
		#if %_RT_CUBEMAP0 && !%_RT_DECAL_TEXGEN_2D  // AO only mode
		nIntegrMode = 0;
		#elif !%_RT_CUBEMAP0 && %_RT_DECAL_TEXGEN_2D  // GI replaces diffuse of env probes and adjusts specular
		nIntegrMode = 1;
		#elif %_RT_CUBEMAP0 && %_RT_DECAL_TEXGEN_2D  // Full GI mode
		nIntegrMode = 2;
		#endif

		ApplyGI(specularAcc, diffuseAcc, 0, pixelUV + .5f / ScreenSize.xy, surfGloss, surfSpecCol,
		        GiDiffuseRT, GiSpecularRT, SampStateTrilinearClamp, nIntegrMode, ForwGiIntegrationMode);
	}
#endif

	// ==============================================================================================
	// SSDO
	// ==============================================================================================
	float4 occlusionData = DirectionalOccRT[pixelCoord];
	occlusionData.xyz = occlusionData.xyz * 2 - 1;
		
	{	
		// Ambient occlusion
		float occlDiff = saturate( 1 - occlusionData.a * SSDOParams.y );
		occlDiff *= occlDiff;

		// Apply simple color bleeding approximation to AO (1/8 resolution)
		float3 bleedColor = AOColorBleedRT.SampleLevel( SampStateTrilinearClamp, pixelUV, 0 );
		diffuseAcc *= pow( occlDiff, 1 - min( bleedColor * bleedColor * bleedColor * 3, 0.7 ) );
		
		// Specular occlusion
		float NdotV = dot( -normalize( position ), surfNormal );
		float ao = saturate( 1 - occlusionData.a * SSDOParams.z );
		float occlSpec = DeriveSpecularOcclusion( NdotV, max(ao * ao, 0.3), surfGloss );
		specularAcc *= occlSpec;
	}
		
	// ==============================================================================================
	// Ambient lights
	// ==============================================================================================
	{
		while (curLight < sTileLightCount)
		{
			int lightType = TiledLightsShadeInfo[lightIndex].lightType;
			if (lightType != LIGHT_TYPE_AMBIENT_AREA)
				break;

			const float clipVolumeBlendWeight = CalcClipVolumeBlendWeight(clipVolumeStencilID, clipVolumeData, clipVolumeBlendFactor, TiledLightsShadeInfo[lightIndex].stencilID);
			bool skipShading = clipVolumeBlendWeight == 0.0;
		
			[branch] if (!skipShading)
			{
				float3 lightVec = TiledLightsShadeInfo[lightIndex].posRad.xyz - (position + GetWorldViewPos());
				float  lightAtt = TiledLightsShadeInfo[lightIndex].posRad.w;
			
				float filter = 1;
				float attenuation;
				float NdotL;
				float PdotL = 1;
			
				[branch] if (lightType == LIGHT_TYPE_AMBIENT_AREA)
				{
					lightVec = ComputeNearestLightOnRectangle(lightVec, TiledLightsShadeInfo[lightIndex].projectorMatrix);

					attenuation = GetAttenuation( lightVec, rcp(lightAtt) );
				
					lightVec = normalize( lightVec );
					PdotL = dot( -lightVec, TiledLightsShadeInfo[lightIndex].projectorMatrix[0].xyz );

					attenuation *= GetSpotAttenuation(PdotL, TiledLightsShadeInfo[lightIndex].projectorMatrix[3].w, lightAtt); // spot falloff for area light
					attenuation *= attenuation;
				
					NdotL = saturate( dot( surfNormal, lightVec ) ) * saturate( PdotL );
				}
				else
				{
					[branch] if (TiledLightsShadeInfo[lightIndex].attenuationParams.x > 0)
						attenuation = GetPhysicalLightAttenuation( length( lightVec ), rcp(lightAtt), TiledLightsShadeInfo[lightIndex].attenuationParams.x );
					else
						attenuation = GetAttenuation( lightVec, rcp(lightAtt) );
				
					lightVec = normalize( lightVec );
					NdotL = saturate( dot( surfNormal, lightVec ) );
				
					if (lightType == LIGHT_TYPE_AMBIENT_PROJECTOR)
					{
						filter = 0;
						[branch] if (attenuation > 0)
						{
							float4 vProjTC = mul( TiledLightsShadeInfo[lightIndex].projectorMatrix, float4( position + GetWorldViewPos(), 1 ) );
							vProjTC.xy /= vProjTC.w;
						
							if (vProjTC.w > 0 && max( abs(vProjTC.x * 2 - 1), abs(vProjTC.y * 2 - 1) ) < 1)  // Avoid back-projection
							{
								uint4 resIndexClamps = GetResourceIndexAndMipClamps(TiledLightsShadeInfo[lightIndex].resIndex);
								filter = SpotTexArray.SampleLevel( SampStateTrilinearClamp, float3( vProjTC.xy, resIndexClamps.x ), resIndexClamps.y ).x;
							}
						}
					}
					else
					{
						attenuation *= attenuation;
					}
				}
			
				float3 lightColor = TiledLightsShadeInfo[lightIndex].color.rgb;

				// Darkening ambient lights don't use any directionality
				float lightOccl = 0.3 + 0.7 * (1.0 - saturate( dot( lightVec, occlusionData.xyz ) * SSDOParams.x ));
				float3 dirFactor = lightColor > 1 ? float3( NdotL, NdotL, NdotL ) * lightOccl : saturate( float3( PdotL, PdotL, PdotL ) );
			
				attenuation *= clipVolumeBlendWeight;
				float3 lightTerm = lerp( float3( 1, 1, 1 ), lightColor, attenuation * filter * dirFactor );
				diffuseAcc *= lightTerm;
				specularAcc *= lightTerm;
			}
		
			++curLight;
			lightIndex = sTileLightIndices[min( curLight, TILED_SHADING_MAX_NUM_LIGHTS - 1 )];
		}
	}
	
	// ==============================================================================================
	// SSR, Fresnel and Caustics
	// ==============================================================================================
	{
		// Apply Screenspace Reflections (1/2 resolution)
#if %_RT_SAMPLE3
		float4 ssRefl =  SSReflectionRT.SampleLevel( SampStateTrilinearClamp, pixelUV, 0 );
		specularAcc = lerp( specularAcc, ssRefl.xyz, ssRefl.w );
#endif

		// Apply Fresnel
		float2 envBRDF = EnvBRDF.SampleLevel( SampStateTrilinearClamp, float2( dot( -normalize( position ), surfNormal ), surfGloss ), 0 ).xy;
		float3 envFresnel = lerp( envBRDF.xxx, envBRDF.yyy, surfSpecCol );
		specularAcc *= envFresnel;
	
		// Apply water caustics (full resolution)
		float3 caustics = CausticsRT[pixelCoord];
		diffuseAcc += caustics;
	}
		
	// ==============================================================================================
	// Regular lights
	// ==============================================================================================
	{
		while (curLight < sTileLightCount)
		{
			int    lightType = TiledLightsShadeInfo[lightIndex].lightType;
			float3 lightVec  = TiledLightsShadeInfo[lightIndex].posRad.xyz - (position + GetWorldViewPos());
			float  lightAtt  = TiledLightsShadeInfo[lightIndex].posRad.w;
		
			float3 lightVecAreaSpec;
			float attenuation;
			float PdotL = 1;
		
			[branch] if (lightType == LIGHT_TYPE_SUN)
			{
				lightVec = SunDir.xyz;
				lightVecAreaSpec = SunDir.xyz * SunDir.w;
				attenuation = (TiledClipVolumeInfo[clipVolumeStencilID].data & CLIPVOLUME_AFFECTED_BY_SUN) ? 1.0 : 0.0;
			}
			else
			{
				const float clipVolumeBlendWeight = CalcClipVolumeBlendWeight(clipVolumeStencilID, clipVolumeData, clipVolumeBlendFactor, TiledLightsShadeInfo[lightIndex].stencilID);
				lightVecAreaSpec = lightVec;
				attenuation = GetPhysicalLightAttenuation( length( lightVec ), rcp(lightAtt), TiledLightsShadeInfo[lightIndex].attenuationParams.x ) * clipVolumeBlendWeight;

				lightVec = normalize( lightVec );
			}
		
			float NdotL = saturate( dot( surfNormal, lightVec ) ) * saturate( PdotL );
		
			[branch] if (attenuation > 0 && (NdotL > 0 || surfIsTranslucent || lightType == LIGHT_TYPE_REGULAR_AREA)) 
			{
				float lightTerm = 1;
				bool shadowMap = TiledLightsShadeInfo[lightIndex].shadowParams.x > 0;
				bool skipShading = false;
			
				[branch] if (lightType != LIGHT_TYPE_SUN)
				{
					[branch] if (lightType == LIGHT_TYPE_REGULAR_PROJECTOR)
					{
						float4 vProjTC = mul(TiledLightsShadeInfo[lightIndex].projectorMatrix, float4(position + GetWorldViewPos(), 1));
						vProjTC.xy /= vProjTC.w;
					
						[branch] if (vProjTC.w < 0 || max( abs(vProjTC.x * 2 - 1), abs(vProjTC.y * 2 - 1) ) > 1)  // Avoid back-projection
							skipShading = true;
						else
						{
							uint4 resIndexClamps = GetResourceIndexAndMipClamps(TiledLightsShadeInfo[lightIndex].resIndex);
							lightTerm = SpotTexArray.SampleLevel( SampStateTrilinearClamp, float3( vProjTC.xy, resIndexClamps.x ), resIndexClamps.y ).r;
						}
					}
					else if (lightType == LIGHT_TYPE_REGULAR_POINTFACE)
					{
						skipShading = (TiledLightsShadeInfo[lightIndex].resIndex != selectCubeFace(lightVec));
					}
				}
			
				[branch] if (!skipShading)
				{
					float4 lightColor = TiledLightsShadeInfo[lightIndex].color;
					float shadowTerm = 1.0;
				
					[branch] if (shadowMap)
					{
						int3 sampleCoords = int3(pixelCoord, TiledLightsShadeInfo[lightIndex].shadowMaskIndex);
						shadowTerm = 1 - ShadowMaskRT[sampleCoords];
					}
				
					[branch] if (shadowTerm > 0)
					{
						float lightOccl = 1.0 - saturate( dot( lightVec, occlusionData.xyz ) * SSDOParams.x );
						lightOccl *= lightOccl;
						lightTerm *= attenuation * shadowTerm * lightOccl;

						float3 diffuseTerm = 0;
						float3 specTerm = 0;
						float3 diffuseTranslucency = 0;

						if (lightType == LIGHT_TYPE_REGULAR_AREA)
						{
							float3 lightPos = TiledLightsShadeInfo[lightIndex].posRad.xyz - GetWorldViewPos();
							uint4 resIndexClamps = GetResourceIndexAndMipClamps( TiledLightsShadeInfo[lightIndex].resIndex );
							AreaLightLTC_GGX( surfNormal, -normalize( position ), surfGloss, surfSpecCol, position, lightPos, 
                                              resIndexClamps.x, TiledLightsShadeInfo[lightIndex].projectorMatrix, SpotTexArray, diffuseTerm, specTerm );

							diffuseAcc += ( lightTerm * lightColor.rgb ) * diffuseTerm;
							specularAcc += ( lightTerm * lightColor.rgb ) * lightColor.a * specTerm;
						}
						else
						{
							diffuseTerm = DiffuseBRDF( surfNormal, -normalize( position ), lightVec, surfGloss, NdotL );
							specTerm = SpecularBRDF( surfNormal, -normalize( position ), lightVec, surfGloss, surfSpecCol );
							diffuseTranslucency = ThinTranslucencyBRDF( surfNormal, lightVec, surfTransmittanceColor );

							diffuseAcc += ( lightTerm * lightColor.rgb ) * ( surfIsTranslucent ? diffuseTranslucency : diffuseTerm.xxx );
							specularAcc += ( lightTerm * lightColor.rgb ) * lightColor.a * specTerm * NdotL;
						}
					}
				}
			}		
			++curLight;
			lightIndex = sTileLightIndices[min( curLight, TILED_SHADING_MAX_NUM_LIGHTS - 1 )];
		}
	}
	
	// ==============================================================================================
	// Subsurface Scattering and final composition
	// ==============================================================================================
	{
		// Apply albedo
		float4 albedoSSS = DecodeGBufferAlbedoAndScattering( DiffuseRT[pixelCoord] );
		float scatteringIndex = albedoSSS.w;
		float3 surfAlbedo = albedoSSS.rgb;
		surfAlbedo *= saturate( 1 - GetLuminance( surfSpecCol ) );  // Simple energy conservation between specular and diffuse
	
		float3 finalCol = diffuseAcc * surfAlbedo + specularAcc;
	
		// Subsurface Scattering
#if %_RT_SAMPLE4	
		[branch] if (scatteringIndex > 0)
		{
			finalCol = specularAcc;
			diffuseAcc *= floor( scatteringIndex ) != SSS_PROFILE_SKIN ? sqrt( surfAlbedo ) : 1;
		}
		else
		{
			diffuseAcc = 0;
		}
	
		DiffuseAccUAV[pixelCoord] = float3( diffuseAcc );
#endif

		HDRSceneTargetUAV[pixelCoord] = float3( finalCol );
	}
#endif
}


technique TiledDeferredShading
{
  pass p0
  {
    ComputeShader = TiledDeferredShadingCS() TiledShadingCS;
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

RWBuffer<uint> VolumeOpaqueLightMaskUAV : register(u0);
RWBuffer<uint> VolumeTranspLightMaskUAV : register(u1);
Buffer<float4> VolumeVertexData         : register(t0);
StructuredBuffer<STiledLightVolumeInfo>   TiledLightsVolumeInfo : register(t1);

cbuffer CBVolumeLightListGen : register(b0)
{
	struct
	{
		float4x4 matViewProj;
		uint     lightIndexOffset;
		uint     numVertices;
		float4   screenScale;
		float4   viewerPos;
		float4   worldBasisX;
		float4   worldBasisY;
		float4   worldBasisZ;
	} cbVolumeLightListGen;
};

struct vtxOutVolumeLightListGen
{
	float4                WPos        : SV_Position;
	nointerpolation uint  lightIndex  : TEXCOORD0;
};

vtxOutVolumeLightListGen VolumeLightListGenVS(uint VertexID : SV_VertexID)
{
	vtxOutVolumeLightListGen OUT = (vtxOutVolumeLightListGen)0; 
	
	const uint numVertices = cbVolumeLightListGen.numVertices;
	const uint vertexIndex = VertexID % numVertices;
	const uint lightIndex = VertexID / numVertices + cbVolumeLightListGen.lightIndexOffset;
	
	float4 pos = VolumeVertexData[vertexIndex];
	pos = mul(pos, TiledLightsVolumeInfo[lightIndex].worldMat);
	pos = mul(pos, cbVolumeLightListGen.matViewProj);
	
	OUT.WPos = pos;
	OUT.lightIndex = lightIndex;

	return OUT;
}

[earlydepthstencil]
void VolumeLightListGenPS(vtxOutVolumeLightListGen IN, bool bIsFrontFace : SV_IsFrontFace)
{
	const uint lightIndex = IN.lightIndex;
	const uint2 pixelPos = IN.WPos.xy;
	
	float2 depthMaxMin = DepthTex.Load(int3(pixelPos.xy, 0)).xy;
	float3 positionMax = CalcHomogeneousPos(1, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
	float3 positionMin = CalcHomogeneousPos(0, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
		
	STiledLightVolumeInfo volume = TiledLightsVolumeInfo[lightIndex];
	uint volumeType = volume.volumeTypeInfo.x;
	uint lightId = volume.volumeTypeInfo.w;
	
	uint2 numTiles = (uint2)cbVolumeLightListGen.screenScale.xy;
	uint tileIdx = pixelPos.y * numTiles.x + pixelPos.x;
	uint bufferBaseIdx = tileIdx * 8;
	
	bool bInVolume = (volumeType == TILEDLIGHT_VOLUME_SUN) ? true : false;
	bool bInTranspVolume = bInVolume;
	
	if (volumeType == TILEDLIGHT_VOLUME_OBB)
	{
		// Transform into OBB space
		float3 volumePos = float3(volume.volumeParams0.w, volume.volumeParams1.w, volume.volumeParams2.w) - cbVolumeLightListGen.viewerPos;
		float3 posMinLS = mul(float3x3(volume.volumeParams0.xyz, volume.volumeParams1.xyz, volume.volumeParams2.xyz), volumePos - positionMin.xyz);
		float3 posMaxLS = mul(float3x3(volume.volumeParams0.xyz, volume.volumeParams1.xyz, volume.volumeParams2.xyz), volumePos - positionMax.xyz);
		
		float3 rayOrig = posMinLS;
		float3 rayDir = normalize(posMaxLS - posMinLS);
			
		// Intersect ray with AABB
		float3 rcpDir = rcp(rayDir);
		float3 tneg = (-volume.volumeParams3.xyz - rayOrig) * rcpDir;
		float3 tpos = ( volume.volumeParams3.xyz - rayOrig) * rcpDir;
		float3 tmin = min(tneg, tpos);
		float3 tmax = max(tneg, tpos);
		float t0 = max(max(tmin.x, tmin.y), tmin.z);
		float t1 = min(min(tmax.x, tmax.y), tmax.z);
		if (t0 <= t1)
		{
			positionMin = CalcHomogeneousPos(depthMaxMin.y, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
			positionMax = CalcHomogeneousPos(depthMaxMin.x, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
			posMinLS = mul(float3x3(volume.volumeParams0.xyz, volume.volumeParams1.xyz, volume.volumeParams2.xyz), volumePos - positionMin.xyz);
			posMaxLS = mul(float3x3(volume.volumeParams0.xyz, volume.volumeParams1.xyz, volume.volumeParams2.xyz), volumePos - positionMax.xyz);
			
			if (t0 <= length(posMaxLS - rayOrig))
			{
				bInTranspVolume = true;
				if (t1 >= length(posMinLS - rayOrig))
					bInVolume = true;
			}
		}
	}
	else if (volumeType == TILEDLIGHT_VOLUME_CONE)
	{
		positionMin = CalcHomogeneousPos(depthMaxMin.y, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
		positionMax = CalcHomogeneousPos(depthMaxMin.x, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
		
		float3 forwardVec = volume.volumeParams1.xyz;
		float3 upVector = abs(forwardVec.z) < 0.999 ? float3(0, 0, 1) : float3(1, 0, 0);
		float3 tangentX = normalize(cross(upVector, forwardVec));
		float3 tangentY = cross(forwardVec, tangentX);
		
		// Compute projector frustum's left, right, top and bottom planes
		float cosFOV = volume.volumeTypeInfo.z;
		float sinFOV = volume.volumeTypeInfo.y;
		float3 N0 =  tangentX * cosFOV - forwardVec * sinFOV;
		float3 N1 = -tangentX * cosFOV - forwardVec * sinFOV;
		float3 N2 =  tangentY * cosFOV - forwardVec * sinFOV;
		float3 N3 = -tangentY * cosFOV - forwardVec * sinFOV;
		
		// Check near plane
		const float3 P0 = volume.volumeParams0.xyz - cbVolumeLightListGen.viewerPos;
		bInVolume = dot(-volume.volumeParams1.xyz, positionMin - P0) >= 0 || dot(-volume.volumeParams1.xyz, positionMax - P0) >= 0;
		
		// Check if min and max position are both on same side of planes
		if (dot(N0, positionMin - P0) < 0 && dot(N0, positionMax - P0) < 0) bInVolume = false;
		if (dot(N1, positionMin - P0) < 0 && dot(N1, positionMax - P0) < 0) bInVolume = false;
		if (dot(N2, positionMin - P0) < 0 && dot(N2, positionMax - P0) < 0) bInVolume = false;
		if (dot(N3, positionMin - P0) < 0 && dot(N3, positionMax - P0) < 0) bInVolume = false;
		
		// Far plane
		float3 P1 = P0 - volume.volumeParams1.xyz * volume.volumeParams0.w;
		if (dot(volume.volumeParams1.xyz, positionMin - P1) < 0 && dot(volume.volumeParams1.xyz, positionMax - P1) < 0) bInVolume = false;
		
		// TODO: Implement culling for transparent case - this is very inefficient now
		bInTranspVolume = true;
	}
	else if (volumeType == TILEDLIGHT_VOLUME_SPHERE)
	{
		float3 rayOrig = positionMin;
		float3 rayDir = normalize(positionMax - positionMin);
		
		// Intersect ray with sphere
		float3 volumePos = volume.volumeParams0.xyz - cbVolumeLightListGen.viewerPos;
		float3 v = volumePos - rayOrig;
		float b = dot(v, rayDir);
		float radius2 = volume.volumeParams0.w * volume.volumeParams0.w;
		float d2 = radius2 - (dot(v, v) - b * b);
		if (d2 >= 0)
		{
			float t0 = b - sqrt(d2);
			float t1 = b + sqrt(d2);
			
			positionMin = CalcHomogeneousPos(depthMaxMin.y, pixelPos.xy, cbVolumeLightListGen.worldBasisX, cbVolumeLightListGen.worldBasisY, cbVolumeLightListGen.worldBasisZ);
			
			bInTranspVolume = true;
			if (t1 >= length(positionMin - rayOrig))
				bInVolume = true;
		}
	}
	
	uint maskIndex = lightId / 32;
	[branch] if (bInTranspVolume)
		InterlockedOr(VolumeTranspLightMaskUAV[bufferBaseIdx + maskIndex], 1 << (lightId & 31));
	[branch] if (bInVolume)
		InterlockedOr(VolumeOpaqueLightMaskUAV[bufferBaseIdx + maskIndex], 1 << (lightId & 31));
}

technique VolumeLightListGen
{
  pass p0
  {
    VertexShader = VolumeLightListGenVS();
    PixelShader  = VolumeLightListGenPS();
  }
}

#endif
